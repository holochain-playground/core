{"version":3,"file":"connect-to-conductors.js","sourceRoot":"","sources":["../../src/processors/connect-to-conductors.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2RG","sourcesContent":["/* import { Blackboard } from '../blackboard/blackboard';\nimport { Conductor } from '../types/conductor';\nimport { hookUpConductors } from './message';\nimport { Header } from '../types/header';\nimport { Entry, EntryType } from '../types/entry';\nimport { CellContents, Cell } from '../core/cell';\nimport { entryToDHTOps, hashDHTOp } from '../types/dht-op';\n\nexport function checkConnection(url: string): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const ws = new WebSocket(url);\n    ws.onerror = () => reject();\n    ws.onopen = () => {\n      debugger;\n      connect({ url, wsClient: ws })\n        .then(({ call }) => {\n          call('debug/running_instances')({})\n            .then(() => resolve())\n            .catch(() => reject());\n        })\n        .catch(reject);\n    };\n  });\n}\n\nconst globalCAS = {};\n\nexport async function connectToConductors(\n  blackboard: Blackboard<Playground>,\n  conductorsUrls: string[]\n): Promise<void> {\n  const initialPlayground: Playground = {\n    activeAgentPubKey: null,\n    activeDna: null,\n    activeEntryHash: null,\n    conductors: [],\n    conductorsUrls,\n  };\n\n  const promises = conductorsUrls.map(async (url) => {\n    const { onSignal, call } = await connect({ url });\n\n    const contents = await getCellContents(call);\n\n    const agentIds = contents.map((c) => c.agentId);\n\n    const conductor = new Conductor(undefined, {\n      agentIds,\n    });\n\n    for (const content of contents) {\n      const cell = Cell.from(conductor, content);\n      conductor.cells[cell.dna] = cell;\n      cell.updateDHTShard();\n    }\n\n    let numHeldEntries = 0;\n    let numHeldAspects = 0;\n    let lastRefresh = 0;\n    onSignal(async (params) => {\n      const instance_id = Object.keys(params.instance_stats)[0];\n      const newHeldEntries =\n        params.instance_stats[instance_id].number_held_entries;\n      const newHeldAspects =\n        params.instance_stats[instance_id].number_held_aspects;\n\n      if (\n        newHeldEntries == numHeldEntries ||\n        newHeldAspects == numHeldAspects ||\n        Date.now() - lastRefresh < 5000\n      )\n        return;\n\n      lastRefresh = Date.now();\n\n      numHeldAspects = newHeldAspects;\n      numHeldEntries = newHeldEntries;\n\n      const stateDump = await call('debug/state_dump')({\n        instance_id: instance_id,\n        source_chain: true,\n        held_aspects: true,\n        queued_holding_workflows: false,\n      });\n      const cellContent = await processStateDump(call, instance_id, stateDump);\n\n      const conductorIndex = initialPlayground.conductors.findIndex((c) =>\n        c.agentIds.includes(cellContent.agentId)\n      );\n      const conductor = initialPlayground.conductors[conductorIndex];\n      const cell = Cell.from(conductor, cellContent);\n      conductor.cells[cell.dna] = cell;\n      cell.updateDHTShard();\n\n      blackboard.update('conductors', initialPlayground.conductors);\n    });\n\n    return conductor;\n  });\n\n  initialPlayground.conductors = await Promise.all(promises);\n\n  initialPlayground.activeDna = Object.keys(\n    initialPlayground.conductors[0].cells\n  )[0];\n\n  hookUpConductors(initialPlayground.conductors);\n\n  blackboard.updateState(initialPlayground);\n  console.log(initialPlayground.conductors);\n}\n\nexport async function getCellContents(call): Promise<Array<CellContents>> {\n  const instancesIds: Array<string> = await call('debug/running_instances')({});\n\n  const promises = instancesIds.map((id) => getCellContent(call, id));\n  return Promise.all(promises);\n}\n\nexport async function fetchCas(\n  call,\n  instance_id: string,\n  address: string\n): Promise<any> {\n  if (globalCAS[address]) return globalCAS[address];\n  const casResult = await call('debug/fetch_cas')({\n    instance_id,\n    address: address,\n  });\n  globalCAS[address] = casResult;\n  return casResult;\n}\n\nexport async function getCellContent(\n  call,\n  instance_id: string\n): Promise<CellContents> {\n  const stateDump = await call('debug/state_dump')({\n    instance_id,\n    source_chain: true,\n    held_aspects: true,\n    queued_holding_workflows: false,\n  });\n  console.log(stateDump);\n\n  const cellContent = await processStateDump(call, instance_id, stateDump);\n  return cellContent;\n}\n\nasync function getDnaHeader(\n  call,\n  instanceId: string,\n  dnaHeaderAddress: string\n): Promise<any> {\n  const header = await fetchCas(call, instanceId, dnaHeaderAddress);\n  return JSON.parse(header.content);\n}\n\nexport async function processStateDump(\n  call,\n  instanceId: string,\n  stateDump: any\n): Promise<CellContents> {\n  const CAS = {};\n\n  const agentIdHeader = stateDump.source_chain[0][0].header;\n  const dnaHeader = await getDnaHeader(call, instanceId, agentIdHeader.link);\n  const dna = dnaHeader.entry_address;\n  const agentId = agentIdHeader.entry_address;\n\n  stateDump.source_chain.unshift([\n    { entry: null, header: dnaHeader },\n    agentIdHeader.link,\n  ]);\n\n  const promises = stateDump.source_chain.map(\n    async ([headerWithEntry, headerAddress]) => {\n      const header = headerWithEntry.header;\n      CAS[headerAddress] = processHeader(header);\n\n      const casResult = await fetchCas(call, instanceId, header.entry_address);\n\n      CAS[header.entry_address] = processEntry(dna, agentId, casResult);\n    }\n  );\n\n  const aspects = Object.keys(stateDump.held_aspects);\n\n  const dhtPromises = aspects.map(async (aspect) => {\n    const op = await fetchCas(call, instanceId, aspect);\n\n    if (op.type !== 'UNKNOWN') return [];\n    const headerAspect = JSON.parse(op.content);\n    const header = processHeader(headerAspect);\n    const entry = await fetchCas(call, instanceId, header.entry_address);\n\n    const ops = entryToDHTOps(processEntry(dna, agentId, entry), header);\n    return ops;\n  });\n\n  const dhtOps = await Promise.all(dhtPromises);\n\n  const DHTOpTransforms = {};\n\n  for (const dhtOp of [].concat(...dhtOps)) {\n    const dhtOpId = await hashDHTOp(dhtOp);\n    DHTOpTransforms[dhtOpId] = dhtOp;\n  }\n\n  const sourceChain = stateDump.source_chain.map(\n    ([headerWithEntry, headerAddress]) => headerAddress\n  );\n\n  await Promise.all(promises);\n\n  return {\n    CAS,\n    dna,\n    agentId,\n    peers: [],\n    redundancyFactor: 0,\n    sourceChain: sourceChain,\n    CASMeta: {},\n    DHTOpTransforms,\n  };\n}\n\nexport function processHeader(header: any): Header {\n  return {\n    agent_id: header.provenances[0][0],\n    entry_address: header.entry_address,\n    last_header_address: header.link,\n    timestamp: Math.floor(new Date(header.timestamp).getTime() / 1000),\n    replaced_entry_address: header.link_update_delete,\n  };\n}\n\nexport function processEntry(dna: string, agent_id: string, entry: any): Entry {\n  switch (entry.type) {\n    case '%dna':\n      return {\n        type: EntryType.DNA,\n        payload: dna,\n      };\n    case '%agent_id':\n      return {\n        type: EntryType.AgentId,\n        payload: agent_id,\n      };\n    case '%cap_token_grant':\n      return {\n        type: EntryType.CapTokenGrant,\n        payload: JSON.parse(entry.content).CapTokenGrant,\n      };\n    case '%link_add':\n      return {\n        type: EntryType.LinkAdd,\n        payload: processLinkContent(entry.content),\n      };\n    default:\n      return {\n        type: EntryType.CreateEntry,\n        payload: {\n          type: entry.type,\n          content: JSON.parse(entry.content),\n        },\n      };\n  }\n}\n\nexport function processLinkContent(\n  link: string\n): { base: string; target: string; type: string; tag: string } {\n  const parsed = link.split(')');\n  const typeTag = parsed[0].trim().split('#');\n  const baseTarget = parsed[1].split('=>');\n  return {\n    base: baseTarget[0].trim(),\n    target: baseTarget[1].trim(),\n    type: typeTag[0].substring(1),\n    tag: typeTag[1],\n  };\n}\n */"]}