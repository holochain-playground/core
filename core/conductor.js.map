{"version":3,"file":"conductor.js","sourceRoot":"","sources":["../../src/core/conductor.ts"],"names":[],"mappings":"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","sourcesContent":["import { CellId, Hash } from '@holochain-open-dev/core-types';\nimport { serializeHash } from '@holochain-open-dev/common';\nimport { Cell } from '../core/cell';\nimport { hash } from '../processors/hash';\nimport { Network, NetworkState } from './network';\n\nimport { SimulatedDna } from '../dnas/simulated-dna';\nimport { CellState } from './cell/state';\n\nexport interface ConductorState {\n  cellsState: Array<{ id: CellId; state: CellState; dna?: SimulatedDna }>;\n  networkState: NetworkState;\n}\n\nexport class Conductor {\n  readonly cells: Array<{ id: CellId; cell: Cell }>;\n\n  network: Network;\n\n  constructor(state: ConductorState) {\n    this.network = new Network(state.networkState);\n    this.cells = state.cellsState.map(({ id, state, dna }) => ({\n      id,\n      cell: new Cell(state, this.network.createP2pCell(id), dna),\n    }));\n  }\n\n  static async create(): Promise<Conductor> {\n    const state: ConductorState = {\n      cellsState: [],\n      networkState: {\n        p2pCellsState: [],\n      },\n    };\n\n    return new Conductor(state);\n  }\n\n  getState(): ConductorState {\n    return {\n      networkState: this.network.getState(),\n      cellsState: this.cells.map((c) => ({\n        id: c.id,\n        state: c.cell.getState(),\n      })),\n    };\n  }\n\n  getCells(dnaHash: Hash): Cell[] {\n    const dnaHashStr = serializeHash(dnaHash);\n    return this.cells\n      .filter((cell) => serializeHash(cell.id[1]) === dnaHashStr)\n      .map((c) => c.cell);\n  }\n\n  async installDna(dna: SimulatedDna, membrane_proof: any): Promise<Cell> {\n    const rand = Math.random().toString();\n    const agentId = hash(rand);\n\n    const cell = await Cell.create(this, dna, agentId, membrane_proof);\n\n    this.cells.push({ id: cell.cellId, cell });\n\n    return cell;\n  }\n\n  callZomeFn(args: {\n    cellId: CellId;\n    zome: string;\n    fnName: string;\n    payload: any;\n    cap: string;\n  }): Promise<any> {\n    const cell = this.cells.find(\n      (cell) => cell.id[0] === args.cellId[0] && cell.id[1] === args.cellId[1]\n    );\n\n    if (!cell)\n      throw new Error(\n        `No cells existst with cellId ${args.cellId[0]}:${args.cellId[1]}`\n      );\n\n    return cell.cell.callZomeFn({\n      zome: args.zome,\n      cap: args.cap,\n      fnName: args.fnName,\n      payload: args.payload,\n    });\n  }\n}\n"]}