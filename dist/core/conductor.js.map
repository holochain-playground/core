{"version":3,"file":"conductor.js","sourceRoot":"","sources":["../../src/core/conductor.ts"],"names":[],"mappings":"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","sourcesContent":["import { CellId, Dictionary, Hash } from '@holochain-open-dev/core-types';\nimport { serializeHash } from '@holochain-open-dev/common';\nimport { Cell } from '../core/cell';\nimport { hash } from '../processors/hash';\nimport { Network, NetworkState } from './network';\n\nimport { SimulatedDna, SimulatedDnaTemplate } from '../dnas/simulated-dna';\nimport { CellState } from './cell/state';\n\nexport interface ConductorState {\n  cellsState: Array<{ id: CellId; state: CellState }>;\n  networkState: NetworkState;\n  registeredTemplates: Dictionary<SimulatedDnaTemplate>;\n  registeredDnas: Dictionary<SimulatedDna>;\n}\n\nexport class Conductor {\n  readonly cells: Array<{ id: CellId; cell: Cell }>;\n  registeredTemplates!: Dictionary<SimulatedDnaTemplate>;\n  registeredDnas!: Dictionary<SimulatedDna>;\n\n  network: Network;\n\n  constructor(state: ConductorState) {\n    this.network = new Network(state.networkState);\n    this.cells = state.cellsState.map(({ id, state }) => ({\n      id,\n      cell: new Cell(this, state, this.network.createP2pCell(id)),\n    }));\n    this.registeredDnas = state.registeredDnas;\n    this.registeredTemplates = state.registeredTemplates;\n  }\n\n  static async create(): Promise<Conductor> {\n    const state: ConductorState = {\n      cellsState: [],\n      networkState: {\n        p2pCellsState: [],\n      },\n      registeredDnas: {},\n      registeredTemplates: {},\n    };\n\n    return new Conductor(state);\n  }\n\n  getState(): ConductorState {\n    return {\n      networkState: this.network.getState(),\n      cellsState: this.cells.map(c => ({\n        id: c.id,\n        state: c.cell.getState(),\n      })),\n      registeredDnas: this.registeredDnas,\n      registeredTemplates: this.registeredTemplates,\n    };\n  }\n\n  getCells(dnaHash: Hash): Cell[] {\n    const dnaHashStr = serializeHash(dnaHash);\n    return this.cells\n      .filter(cell => serializeHash(cell.id[1]) === dnaHashStr)\n      .map(c => c.cell);\n  }\n\n  async registerDna(dna_template: SimulatedDnaTemplate): Promise<Hash> {\n    const templateHash = hash(dna_template);\n\n    this.registeredTemplates[serializeHash(templateHash)] = dna_template;\n    return templateHash;\n  }\n\n  async installApp(\n    dna_hash: Hash,\n    membrane_proof: any,\n    properties: any,\n    uuid: string\n  ): Promise<Cell> {\n    const rand = `${Math.random().toString()}/${Date.now()}`;\n    const agentId = hash(rand);\n\n    const template = this.registeredTemplates[serializeHash(dna_hash)];\n    if (!template) {\n      throw new Error(`The given dna is not registered on this conductor`);\n    }\n\n    const dna: SimulatedDna = {\n      ...template,\n      properties,\n      uuid,\n    };\n    const dnaHash = hash(dna);\n    this.registeredDnas[serializeHash(dnaHash)] = dna;\n\n    const cellId: CellId = [dnaHash, agentId];\n    const cell = await Cell.create(this, cellId, membrane_proof);\n\n    this.cells.push({ id: cell.cellId, cell });\n\n    return cell;\n  }\n\n  callZomeFn(args: {\n    cellId: CellId;\n    zome: string;\n    fnName: string;\n    payload: any;\n    cap: string;\n  }): Promise<any> {\n    const dnaHashStr = serializeHash(args.cellId[0]);\n    const agentPubKeyStr = serializeHash(args.cellId[1]);\n    const cell = this.cells.find(\n      cell =>\n        serializeHash(cell.id[0]) === dnaHashStr &&\n        serializeHash(cell.id[1]) === agentPubKeyStr\n    );\n\n    if (!cell)\n      throw new Error(\n        `No cells existst with cellId ${dnaHashStr}:${agentPubKeyStr}`\n      );\n\n    return cell.cell.callZomeFn({\n      zome: args.zome,\n      cap: args.cap,\n      fnName: args.fnName,\n      payload: args.payload,\n    });\n  }\n}\n"]}